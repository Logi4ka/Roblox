------------------------------------------------------------
-- Оптимизированный и модульный скрипт меню LogdrinosMenu
-- Каждая функциональность инкапсулирована в свой блок, что
-- позволяет изменять компоненты независимо друг от друга.
------------------------------------------------------------

-- Получаем сервисы Roblox
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Если меню уже существует, прекращаем выполнение
if playerGui:FindFirstChild("LogdrinosMenu") then
	return
end

------------------------------------------------------------
-- Настраиваемые параметры меню
------------------------------------------------------------
local config = {
	menuWidth = 200,
	menuHeight = 250,
	titleBarHeight = 30,
	teleportExtraHeight = 70, -- кнопка телепортации (40) и поле поиска (30)
}
config.teleportListHeight = config.menuHeight - config.titleBarHeight - config.teleportExtraHeight

------------------------------------------------------------
-- Вспомогательные функции
------------------------------------------------------------
local function createUI(className, properties)
	local ui = Instance.new(className)
	for prop, val in pairs(properties) do
		ui[prop] = val
	end
	return ui
end

-- Фильтрация ввода для числовых текстбоксов
local function filterNumericInput(text)
	return text:match("^%d*$") or ""
end

------------------------------------------------------------
-- Глобальное состояние
------------------------------------------------------------
local state = {
	currentSpeed = 16,
	currentJump = 50,
	minSpeed = 16, maxSpeed = 200,
	minJump = 50,  maxJump = 200,
	isFlying = false,
	isNoClip = false,
	isNoFallDamage = false,  -- Новая переменная для отключения урона от падения
	teleportMode = false,
	
	-- Переменные перетаскивания окна
	isDragging = false,
	dragStart = nil,
	startPos = nil,
	wasDragged = false,
	dragThreshold = 5,
	dragInput = nil,
	
	-- Управление слайдерами
	sliderDrag = { speed = false, jump = false },
	sliderInput = { speed = nil, jump = nil },
}

-- Сохранение оригинальных параметров освещения
local originalLighting = {
	Ambient = Lighting.Ambient,
	Brightness = Lighting.Brightness,
	OutdoorAmbient = Lighting.OutdoorAmbient,
	FogStart = Lighting.FogStart,
	FogEnd = Lighting.FogEnd,
	FogColor = Lighting.FogColor,
}

-- Функции обновления скорости и прыжка
local function updateWalkSpeed(speed)
	state.currentSpeed = speed
	if player.Character then
		local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = speed
		end
	end
end

local function updateJumpPower(jump)
	state.currentJump = jump
	if player.Character then
		local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
		if humanoid then
			humanoid.JumpPower = jump
		end
	end
end

------------------------------------------------------------
-- МОДУЛЬ UI: Создание всех элементов интерфейса
------------------------------------------------------------
local UI = {}
do
	-- Основной ScreenGui
	UI.screenGui = createUI("ScreenGui", {
		Name = "LogdrinosMenu",
		ResetOnSpawn = false,
	})
	UI.screenGui.Parent = playerGui

	-- Главный фрейм
	UI.mainFrame = createUI("Frame", {
		Name = "MainFrame",
		Size = UDim2.new(0, config.menuWidth, 0, config.menuHeight),
		Position = UDim2.new(0.5, -config.menuWidth/2, 0.5, -config.menuHeight/2),
		BackgroundColor3 = Color3.fromRGB(45,45,45),
		BorderSizePixel = 0,
		Active = true,
		Selectable = true,
	})
	UI.mainFrame.Parent = UI.screenGui
	createUI("UICorner", { CornerRadius = UDim.new(0, 8), Parent = UI.mainFrame })

	-- Заголовок и кнопка сворачивания
	UI.titleBar = createUI("Frame", {
		Name = "TitleBar",
		Size = UDim2.new(1, 0, 0, config.titleBarHeight),
		BackgroundColor3 = Color3.fromRGB(35,35,35),
		BorderSizePixel = 0,
		Active = true,
		Selectable = true,
	})
	UI.titleBar.Parent = UI.mainFrame
	createUI("UICorner", { CornerRadius = UDim.new(0, 8), Parent = UI.titleBar })

	UI.titleText = createUI("TextLabel", {
		Text = "Logdrinos Menu v7.0",
		Size = UDim2.new(1, -40, 1, 0),
		Position = UDim2.new(0, 10, 0, 0),
		BackgroundTransparency = 1,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.GothamBold,
		TextXAlignment = Enum.TextXAlignment.Left,
	})
	UI.titleText.Parent = UI.titleBar

	UI.minimizeButton = createUI("TextButton", {
		Name = "MinimizeButton",
		Size = UDim2.new(0, 20, 0, 20),
		Position = UDim2.new(1, -25, 0, 5),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		Text = "",
		Active = true,
		Selectable = true,
	})
	UI.minimizeButton.Parent = UI.titleBar
	createUI("UICorner", { CornerRadius = UDim.new(0, 4), Parent = UI.minimizeButton })

	UI.indicator = createUI("Frame", {
		Size = UDim2.new(0, 8, 0, 8),
		Position = UDim2.new(0.5, -4, 0.5, -4),
		BackgroundColor3 = Color3.fromRGB(255,255,255),
		BorderSizePixel = 0,
	})
	UI.indicator.Parent = UI.minimizeButton
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.indicator })

	-- Контейнер для элементов меню
	UI.contentFrame = createUI("ScrollingFrame", {
		Name = "ContentFrame",
		Size = UDim2.new(1, 0, 0, config.menuHeight - config.titleBarHeight),
		Position = UDim2.new(0, 0, 0, config.titleBarHeight),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		ScrollBarThickness = 4,
		ScrollBarImageTransparency = 1,
		CanvasSize = UDim2.new(0, 0, 0, 0),
	})
	UI.contentFrame.Parent = UI.mainFrame

	UI.contentListLayout = createUI("UIListLayout", {
		Padding = UDim.new(0, 4),
		SortOrder = Enum.SortOrder.LayoutOrder,
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
	})
	UI.contentListLayout.Parent = UI.contentFrame
	UI.contentListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		UI.contentFrame.CanvasSize = UDim2.new(0, 0, 0, UI.contentListLayout.AbsoluteContentSize.Y + 5)
	end)
	RunService.RenderStepped:Connect(function()
		local pos = UI.contentFrame.CanvasPosition
		if pos.X ~= 0 then
			UI.contentFrame.CanvasPosition = Vector2.new(0, pos.Y)
		end
	end)

	-- Функция создания стандартной кнопки
	function UI.createButton(name, text, order, parent)
		local btn = createUI("TextButton", {
			Name = name,
			Size = UDim2.new(0.9, 0, 0, 40),
			BackgroundColor3 = Color3.fromRGB(65,65,65),
			BorderSizePixel = 0,
			TextColor3 = Color3.fromRGB(255,255,255),
			TextSize = 14,
			Font = Enum.Font.Gotham,
			Text = text,
			Active = true,
			Selectable = true,
		})
		btn.LayoutOrder = order
		btn.Parent = parent
		return btn
	end

	-- Кнопки верхнего ряда
	UI.teleportPlayersButton = UI.createButton("TeleportPlayersButton", "Телепортация к игрокам", 1, UI.contentFrame)
	UI.noClipButton = UI.createButton("NoClipButton", "Ходить сквозь стены", 2, UI.contentFrame)
	UI.flyButton = UI.createButton("FlyButton", "Полёт", 3, UI.contentFrame)
	-- Новая кнопка: отключение урона от падения
	UI.noFallDamageButton = UI.createButton("NoFallDamageButton", "Откл. урон от падения", 4, UI.contentFrame)

	-- Обновляем порядки следующих блоков (увеличены на 1)
	UI.espFrame = createUI("Frame", {
		Name = "EspFrame",
		Size = UDim2.new(1, 0, 0, 84),
		BackgroundTransparency = 1,
		Active = true,
		Selectable = true,
	})
	UI.espFrame.LayoutOrder = 5
	UI.espFrame.Parent = UI.contentFrame

	UI.espListLayout = createUI("UIListLayout", {
		Padding = UDim.new(0, 4),
		SortOrder = Enum.SortOrder.LayoutOrder,
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
	})
	UI.espListLayout.Parent = UI.espFrame

	UI.espPlayersButton = UI.createButton("ESPPlayersButton", "ESP Игроков", 1, UI.espFrame)
	UI.espNPCButton = UI.createButton("ESPNPCButton", "ESP Существ", 2, UI.espFrame)

	-- Блок освещения
	UI.lightFrame = createUI("Frame", {
		Name = "LightFrame",
		Size = UDim2.new(1, 0, 0, 40),
		BackgroundTransparency = 1,
		Active = true,
		Selectable = true,
	})
	UI.lightFrame.LayoutOrder = 6
	UI.lightFrame.Parent = UI.contentFrame

	UI.lightButton = createUI("TextButton", {
		Size = UDim2.new(0.9, 0, 0, 40),
		Position = UDim2.new(0.05, 0, 0, 0),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.Gotham,
		Text = "Осветить карту",
		Active = true,
		Selectable = true,
	})
	UI.lightButton.Parent = UI.lightFrame

	-- Блок Скорости
	UI.speedFrame = createUI("Frame", {
		Name = "SpeedFrame",
		Size = UDim2.new(1, 0, 0, 60),
		BackgroundTransparency = 1,
		Active = true,
		Selectable = true,
	})
	UI.speedFrame.LayoutOrder = 7
	UI.speedFrame.Parent = UI.contentFrame

	UI.speedButton = createUI("TextButton", {
		Size = UDim2.new(0.9, 0, 0, 40),
		Position = UDim2.new(0.05, 0, 0, 0),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.Gotham,
		Text = "Скорость: " .. state.currentSpeed,
		Active = true,
		Selectable = true,
	})
	UI.speedButton.Parent = UI.speedFrame

	UI.speedInput = createUI("TextBox", {
		Size = UI.speedButton.Size,
		Position = UI.speedButton.Position,
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.Gotham,
		Text = tostring(state.currentSpeed),
		ClearTextOnFocus = true,
		Visible = false,
		Active = true,
		Selectable = true,
	})
	UI.speedInput.Parent = UI.speedFrame
	UI.speedInput:GetPropertyChangedSignal("Text"):Connect(function()
		UI.speedInput.Text = filterNumericInput(UI.speedInput.Text)
	end)

	UI.speedSlider = createUI("Frame", {
		Size = UDim2.new(0.9, 0, 0, 4),
		Position = UDim2.new(0.05, 0, 0, 50),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		Active = true,
		Selectable = true,
	})
	UI.speedSlider.Parent = UI.speedFrame
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.speedSlider })

	-- Кнопка-слайдер для скорости
	local initSpeedPerc = (state.currentSpeed - state.minSpeed) / (state.maxSpeed - state.minSpeed)
	UI.sliderButton = createUI("TextButton", {
		Size = UDim2.new(0, 16, 0, 16),
		Position = UDim2.new(0, 0, 0.5, 0),
		BackgroundColor3 = Color3.fromRGB(255,255,255),
		BorderSizePixel = 0,
		Text = "",
		Active = true,
		Selectable = true,
	})
	UI.sliderButton.Parent = UI.speedSlider
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.sliderButton })

	-- Блок Прыжка
	UI.jumpFrame = createUI("Frame", {
		Name = "JumpFrame",
		Size = UDim2.new(1, 0, 0, 60),
		BackgroundTransparency = 1,
		Active = true,
		Selectable = true,
	})
	UI.jumpFrame.LayoutOrder = 8
	UI.jumpFrame.Parent = UI.contentFrame

	UI.jumpButton = createUI("TextButton", {
		Size = UDim2.new(0.9, 0, 0, 40),
		Position = UDim2.new(0.05, 0, 0, 0),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.Gotham,
		Text = "Прыжок: " .. state.currentJump,
		Active = true,
		Selectable = true,
	})
	UI.jumpButton.Parent = UI.jumpFrame

	UI.jumpInput = createUI("TextBox", {
		Size = UI.jumpButton.Size,
		Position = UI.jumpButton.Position,
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.Gotham,
		Text = tostring(state.currentJump),
		ClearTextOnFocus = true,
		Visible = false,
		Active = true,
		Selectable = true,
	})
	UI.jumpInput.Parent = UI.jumpFrame
	UI.jumpInput:GetPropertyChangedSignal("Text"):Connect(function()
		UI.jumpInput.Text = filterNumericInput(UI.jumpInput.Text)
	end)

	UI.jumpSlider = createUI("Frame", {
		Size = UDim2.new(0.9, 0, 0, 4),
		Position = UDim2.new(0.05, 0, 0, 50),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		Active = true,
		Selectable = true,
	})
	UI.jumpSlider.Parent = UI.jumpFrame
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.jumpSlider })

	-- Кнопка-слайдер для прыжка
	local initJumpPerc = (state.currentJump - state.minJump) / (state.maxJump - state.minJump)
	UI.jumpSliderButton = createUI("TextButton", {
		Size = UDim2.new(0, 16, 0, 16),
		Position = UDim2.new(0, 0, 0.5, 0),
		BackgroundColor3 = Color3.fromRGB(255,255,255),
		BorderSizePixel = 0,
		Text = "",
		Active = true,
		Selectable = true,
	})
	UI.jumpSliderButton.Parent = UI.jumpSlider
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.jumpSliderButton })

	-- Блок для телепортации: поле поиска и список игроков
	UI.searchBox = createUI("TextBox", {
		Name = "SearchBox",
		Size = UDim2.new(0.9, 0, 0, 30),
		BackgroundColor3 = Color3.fromRGB(65,65,65),
		BorderSizePixel = 0,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = 14,
		Font = Enum.Font.Gotham,
		PlaceholderText = "Поиск игрока",
		Text = "",
		Visible = false,
	})
	UI.searchBox.LayoutOrder = 9
	UI.searchBox.Parent = UI.contentFrame

	UI.teleportScrollFrame = createUI("ScrollingFrame", {
		Name = "TeleportScrollFrame",
		Size = UDim2.new(1, 0, 0, config.teleportListHeight),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		ScrollBarThickness = 0,
		Visible = false,
	})
	UI.teleportScrollFrame.LayoutOrder = 10
	UI.teleportScrollFrame.Parent = UI.contentFrame

	UI.teleportListLayout = createUI("UIListLayout", {
		Padding = UDim.new(0, 4),
		SortOrder = Enum.SortOrder.LayoutOrder,
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
	})
	UI.teleportListLayout.Parent = UI.teleportScrollFrame
	UI.teleportListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		UI.teleportScrollFrame.CanvasSize = UDim2.new(0, 0, 0, UI.teleportListLayout.AbsoluteContentSize.Y + 15)
	end)

	-- Минимизированное меню
	UI.minimizedFrame = createUI("TextButton", {
		Name = "MinimizedFrame",
		Size = UDim2.new(0, 40, 0, 40),
		Position = UI.mainFrame.Position,
		BackgroundColor3 = Color3.fromRGB(45,45,45),
		BorderSizePixel = 0,
		Text = "",
		Visible = false,
		Active = true,
		Selectable = true,
	})
	UI.minimizedFrame.Parent = UI.screenGui
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.minimizedFrame })

	UI.minimizedIndicator = createUI("Frame", {
		Size = UDim2.new(0, 16, 0, 16),
		Position = UDim2.new(0.5, -8, 0.5, -8),
		BackgroundColor3 = Color3.fromRGB(255,255,255),
		BorderSizePixel = 0,
	})
	UI.minimizedIndicator.Parent = UI.minimizedFrame
	createUI("UICorner", { CornerRadius = UDim.new(1, 0), Parent = UI.minimizedIndicator })
end

------------------------------------------------------------
-- МОДУЛЬ: Перетаскивание окна
------------------------------------------------------------
do
	local function beginDrag(input, frame)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			state.isDragging = true
			state.dragInput = input
			state.dragStart = input.Position
			state.startPos = frame.Position
			state.wasDragged = false
		end
	end

	local function updateDrag(input)
		if state.isDragging and input == state.dragInput then
			local delta = input.Position - state.dragStart
			if delta.Magnitude > state.dragThreshold then
				state.wasDragged = true
			end
			local newX = state.startPos.X.Offset + delta.X
			local newY = state.startPos.Y.Offset + delta.Y
			local newPos = UDim2.new(state.startPos.X.Scale, newX, state.startPos.Y.Scale, newY)
			if UI.mainFrame.Visible then
				UI.mainFrame.Position = newPos
			elseif UI.minimizedFrame.Visible then
				UI.minimizedFrame.Position = newPos
			end
		end
	end

	local function endDrag(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and input == state.dragInput then
			state.isDragging = false
			state.dragInput = nil
		end
	end

	UI.titleBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			state.dragInput = input
			beginDrag(input, UI.mainFrame)
		end
	end)
	UI.minimizedFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			state.dragInput = input
			beginDrag(input, UI.minimizedFrame)
		end
	end)
	UserInputService.InputChanged:Connect(updateDrag)
	UserInputService.InputEnded:Connect(endDrag)

	UI.minimizedFrame.MouseButton1Click:Connect(function()
		if state.wasDragged then
			state.wasDragged = false
			return
		end
		local minimizedPos = UI.minimizedFrame.Position
		local originalXOffset = minimizedPos.X.Offset - (config.menuWidth - 40)
		local originalPos = UDim2.new(minimizedPos.X.Scale, originalXOffset, minimizedPos.Y.Scale, minimizedPos.Y.Offset)
		UI.mainFrame.Position = originalPos
		UI.mainFrame.Visible = true
		UI.minimizedFrame.Visible = false
	end)
end

------------------------------------------------------------
-- МОДУЛЬ: Кнопка сворачивания меню
------------------------------------------------------------
UI.minimizeButton.MouseButton1Click:Connect(function()
	local mainPos = UI.mainFrame.Position
	local newXOffset = mainPos.X.Offset + config.menuWidth - 40
	local newPos = UDim2.new(mainPos.X.Scale, newXOffset, mainPos.Y.Scale, mainPos.Y.Offset)
	UI.mainFrame.Visible = false
	UI.minimizedFrame.Visible = true
	UI.minimizedFrame.Position = newPos
end)

------------------------------------------------------------
-- МОДУЛЬ: Слайдеры для Скорости и Прыжка
------------------------------------------------------------
local function updateSliderButtonPosition(slider, sliderButton, percentage)
	local sliderSize = slider.AbsoluteSize
	local buttonSize = sliderButton.AbsoluteSize
	local effectiveX = buttonSize.X/2 + (sliderSize.X - buttonSize.X) * percentage
	sliderButton.Position = UDim2.new(0, effectiveX - buttonSize.X/2, 0.5, -buttonSize.Y/2)
end

-- Инициализируем положение слайдеров
updateSliderButtonPosition(UI.speedSlider, UI.sliderButton, (state.currentSpeed - state.minSpeed) / (state.maxSpeed - state.minSpeed))
updateSliderButtonPosition(UI.jumpSlider, UI.jumpSliderButton, (state.currentJump - state.minJump) / (state.maxJump - state.minJump))

local function handleSliderDrag(input, slider, sliderButton, minVal, maxVal, updateCallback)
	local sliderPos = slider.AbsolutePosition
	local sliderSize = slider.AbsoluteSize
	local buttonSize = sliderButton.AbsoluteSize
	local effectiveX = math.clamp(input.Position.X - sliderPos.X, buttonSize.X/2, sliderSize.X - buttonSize.X/2)
	local percentage = (effectiveX - buttonSize.X/2) / (sliderSize.X - buttonSize.X)
	sliderButton.Position = UDim2.new(0, effectiveX - buttonSize.X/2, 0.5, -buttonSize.Y/2)
	local value = math.floor(minVal + (maxVal - minVal) * percentage)
	updateCallback(value)
end

UserInputService.InputChanged:Connect(function(input)
	if state.sliderDrag.speed and input == state.sliderInput.speed then
		handleSliderDrag(input, UI.speedSlider, UI.sliderButton, state.minSpeed, state.maxSpeed, function(newSpeed)
			updateWalkSpeed(newSpeed)
			UI.speedButton.Text = "Скорость: " .. newSpeed
		end)
	end
	if state.sliderDrag.jump and input == state.sliderInput.jump then
		handleSliderDrag(input, UI.jumpSlider, UI.jumpSliderButton, state.minJump, state.maxJump, function(newJump)
			updateJumpPower(newJump)
			UI.jumpButton.Text = "Прыжок: " .. newJump
		end)
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		if input == state.sliderInput.speed then
			state.sliderDrag.speed = false
			state.sliderInput.speed = nil
		end
		if input == state.sliderInput.jump then
			state.sliderDrag.jump = false
			state.sliderInput.jump = nil
		end
	end
end)

for _, obj in ipairs({UI.speedSlider, UI.sliderButton}) do
	obj.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not state.sliderInput.speed then
			state.sliderDrag.speed = true
			state.sliderInput.speed = input
		end
	end)
end

for _, obj in ipairs({UI.jumpSlider, UI.jumpSliderButton}) do
	obj.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not state.sliderInput.jump then
			state.sliderDrag.jump = true
			state.sliderInput.jump = input
		end
	end)
end

------------------------------------------------------------
-- МОДУЛЬ: Телепортация
------------------------------------------------------------
local function updateTeleportList()
	-- Очищаем список
	for _, child in ipairs(UI.teleportScrollFrame:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end
	local search = UI.searchBox.Text:lower() or ""
	for _, targetPlayer in ipairs(Players:GetPlayers()) do
		if targetPlayer ~= player then
			local dispName = targetPlayer.DisplayName
			if search == "" or dispName:lower():find(search, 1, true) then
				local playerButton = createUI("TextButton", {
					Size = UDim2.new(0.9, 0, 0, 30),
					BackgroundColor3 = Color3.fromRGB(65,65,65),
					BorderSizePixel = 0,
					TextColor3 = Color3.fromRGB(255,255,255),
					TextSize = 14,
					Font = Enum.Font.Gotham,
					Text = dispName,
					AutoButtonColor = false,
				})
				playerButton.Parent = UI.teleportScrollFrame
				playerButton.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						playerButton.BackgroundColor3 = Color3.fromRGB(100,100,100)
					end
				end)
				playerButton.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						playerButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
					end
				end)
				playerButton.MouseButton1Click:Connect(function()
					if player.Character and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
						local targetHRP = targetPlayer.Character.HumanoidRootPart
						local newPos = targetHRP.Position - targetHRP.CFrame.LookVector * 5
						player.Character:SetPrimaryPartCFrame(CFrame.new(newPos, targetHRP.Position))
					end
				end)
			end
		end
	end
end

local function toggleTeleportMode()
	state.teleportMode = not state.teleportMode
	if state.teleportMode then
		UI.teleportPlayersButton.Text = "Ввернуться назад"
		UI.flyButton.Visible = false
		UI.noClipButton.Visible = false
		UI.espFrame.Visible = false
		UI.lightFrame.Visible = false
		UI.speedFrame.Visible = false
		UI.jumpFrame.Visible = false
		-- Скрываем кнопки "Режим 3-го лица" и "Откл. урон от падения"
		if UI.thirdPersonUnlockButton then
			UI.thirdPersonUnlockButton.Visible = false
		end
		UI.noFallDamageButton.Visible = false
		UI.searchBox.Visible = true
		UI.teleportScrollFrame.Visible = true
		updateTeleportList()
	else
		UI.teleportPlayersButton.Text = "Телепортация к игрокам"
		UI.flyButton.Visible = true
		UI.noClipButton.Visible = true
		UI.espFrame.Visible = true
		UI.lightFrame.Visible = true
		UI.speedFrame.Visible = true
		UI.jumpFrame.Visible = true
		-- Возвращаем кнопки "Режим 3-го лица" и "Откл. урон от падения"
		if UI.thirdPersonUnlockButton then
			UI.thirdPersonUnlockButton.Visible = true
		end
		UI.noFallDamageButton.Visible = true
		UI.searchBox.Visible = false
		UI.teleportScrollFrame.Visible = false
		for _, child in ipairs(UI.teleportScrollFrame:GetChildren()) do
			if child:IsA("TextButton") then
				child:Destroy()
			end
		end
		UI.searchBox.Text = ""
	end
end

UI.teleportPlayersButton.MouseButton1Click:Connect(toggleTeleportMode)
UI.searchBox:GetPropertyChangedSignal("Text"):Connect(function()
	if state.teleportMode then
		updateTeleportList()
	end
end)
Players.PlayerAdded:Connect(function(plr)
	if state.teleportMode then updateTeleportList() end
end)
Players.PlayerRemoving:Connect(function(plr)
	if state.teleportMode then updateTeleportList() end
end)

------------------------------------------------------------
-- МОДУЛЬ: Освещение карты (улучшенный, изолирующий свет от функции)
------------------------------------------------------------
local lightingToggled = false
-- Сохраняем оригинальные параметры Lighting
originalLighting.ClockTime = Lighting.ClockTime
local originalGlobalShadows = Lighting.GlobalShadows

-- Таблицы для хранения удалённых объектов и состояний
local originalSkies = {}
local originalAtmospheres = {}
local originalLightingEffects = {}
local originalWorkspaceLights = {}  -- [light] = его исходное Enabled
local originalPlayerParts = {}        -- [BasePart] = его исходное CastShadow

-- Отключение всех источников света в workspace (в том числе у игроков)
local function disableWorkspaceLights()
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
			originalWorkspaceLights[obj] = obj.Enabled
			obj.Enabled = false
		end
	end
end

-- Восстановление всех источников света в workspace
local function restoreWorkspaceLights()
	for light, enabled in pairs(originalWorkspaceLights) do
		if light and light.Parent then
			light.Enabled = enabled
		end
	end
	originalWorkspaceLights = {}
end

-- Отключение теней у всех BasePart объектов в персонажах игроков
local function disablePlayerShadows()
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Character then
			for _, part in ipairs(plr.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					-- Сохраняем исходное состояние, если ещё не сохранено
					if originalPlayerParts[part] == nil then
						originalPlayerParts[part] = part.CastShadow
					end
					part.CastShadow = false
				end
			end
		end
	end
end

-- Восстановление теней у BasePart объектов игроков
local function restorePlayerShadows()
	for part, originalValue in pairs(originalPlayerParts) do
		if part and part.Parent then
			part.CastShadow = originalValue
		end
	end
	originalPlayerParts = {}
end

local function toggleLighting()
	lightingToggled = not lightingToggled
	if lightingToggled then
		-- Устанавливаем равномерное освещение от функции
		Lighting.Ambient = Color3.new(1, 1, 1)
		Lighting.Brightness = (originalLighting.Brightness < 2) and 2 or originalLighting.Brightness
		Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
		Lighting.FogStart = 0
		Lighting.FogEnd = 1e9
		Lighting.FogColor = Color3.new(1, 1, 1)
		Lighting.GlobalShadows = false
		Lighting.ClockTime = 12  -- фиксированное время для равномерного освещения

		-- Убираем объекты Sky (сохраняя их)
		for _, obj in ipairs(Lighting:GetChildren()) do
			if obj:IsA("Sky") then
				table.insert(originalSkies, obj)
				obj.Parent = nil
			end
		end

		-- Убираем объекты Atmosphere
		for _, obj in ipairs(Lighting:GetChildren()) do
			if obj:IsA("Atmosphere") then
				table.insert(originalAtmospheres, obj)
				obj.Parent = nil
			end
		end

		-- Убираем эффекты, которые могут влиять на освещение
		for _, obj in ipairs(Lighting:GetChildren()) do
			if obj:IsA("BloomEffect") or obj:IsA("SunRaysEffect") or obj:IsA("ColorCorrectionEffect") or obj:IsA("BlurEffect") then
				table.insert(originalLightingEffects, obj)
				obj.Parent = nil
			end
		end

		-- Отключаем все источники света в workspace (в том числе у игроков)
		disableWorkspaceLights()

		-- Отключаем тени у частей игроков
		disablePlayerShadows()

		UI.lightButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
		UI.lightButton.TextColor3 = Color3.fromRGB(0, 0, 0)
	else
		-- Восстанавливаем исходные параметры Lighting
		Lighting.Ambient = originalLighting.Ambient
		Lighting.Brightness = originalLighting.Brightness
		Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
		Lighting.FogStart = originalLighting.FogStart
		Lighting.FogEnd = originalLighting.FogEnd
		Lighting.FogColor = originalLighting.FogColor
		Lighting.GlobalShadows = originalGlobalShadows
		Lighting.ClockTime = originalLighting.ClockTime

		-- Возвращаем объекты Sky
		for _, obj in ipairs(originalSkies) do
			obj.Parent = Lighting
		end
		originalSkies = {}

		-- Возвращаем объекты Atmosphere
		for _, obj in ipairs(originalAtmospheres) do
			obj.Parent = Lighting
		end
		originalAtmospheres = {}

		-- Возвращаем эффекты
		for _, obj in ipairs(originalLightingEffects) do
			obj.Parent = Lighting
		end
		originalLightingEffects = {}

		-- Восстанавливаем источники света в workspace
		restoreWorkspaceLights()

		-- Восстанавливаем тени у частей игроков
		restorePlayerShadows()

		UI.lightButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
		UI.lightButton.TextColor3 = Color3.fromRGB(255,255,255)
	end
end

UI.lightButton.MouseButton1Click:Connect(toggleLighting)

------------------------------------------------------------
-- МОДУЛЬ: Разблокировка вида от третьего лица с восстановлением исходных настроек
------------------------------------------------------------

-- Переменная для отслеживания состояния (разблокирована ли камера)
local thirdPersonUnlocked = false
-- Таблица для сохранения оригинальных настроек камеры
local originalCameraSettings = {}

-- Создаём кнопку, если её ещё нет
if not UI.thirdPersonUnlockButton then
    UI.thirdPersonUnlockButton = UI.createButton("ThirdPersonUnlockButton", "Режим 3-го лица", 6, UI.contentFrame)
end

UI.thirdPersonUnlockButton.MouseButton1Click:Connect(function()
    local camera = workspace.CurrentCamera
    if not thirdPersonUnlocked then
        -- Сохраняем исходные настройки камеры
        originalCameraSettings.mode = player.CameraMode
        originalCameraSettings.minZoom = player.CameraMinZoomDistance
        originalCameraSettings.maxZoom = player.CameraMaxZoomDistance
        if camera then
            originalCameraSettings.type = camera.CameraType
            originalCameraSettings.subject = camera.CameraSubject
        end

        -- Включаем режим разблокированного вида от третьего лица
        player.CameraMode = Enum.CameraMode.Classic
        player.CameraMinZoomDistance = 0.5
        player.CameraMaxZoomDistance = 100
        if camera then
            camera.CameraType = Enum.CameraType.Custom
            if player.Character then
                local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
                if humanoid then
                    camera.CameraSubject = humanoid
                end
            end
        end

        thirdPersonUnlocked = true
        UI.thirdPersonUnlockButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
        UI.thirdPersonUnlockButton.TextColor3 = Color3.fromRGB(0,0,0)
    else
        -- Восстанавливаем исходные настройки камеры
        if originalCameraSettings.mode then
            player.CameraMode = originalCameraSettings.mode
        end
        if originalCameraSettings.minZoom then
            player.CameraMinZoomDistance = originalCameraSettings.minZoom
        end
        if originalCameraSettings.maxZoom then
            player.CameraMaxZoomDistance = originalCameraSettings.maxZoom
        end
        if camera then
            camera.CameraType = originalCameraSettings.type or Enum.CameraType.Custom
            camera.CameraSubject = originalCameraSettings.subject
        end

        thirdPersonUnlocked = false
        UI.thirdPersonUnlockButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
        UI.thirdPersonUnlockButton.TextColor3 = Color3.fromRGB(255,255,255)
    end
    -- Текст кнопки остаётся неизменным
    UI.thirdPersonUnlockButton.Text = "Режим 3-го лица"
end)

------------------------------------------------------------
-- МОДУЛЬ: Отключение урона от падения через переключение PlatformStand
------------------------------------------------------------

-- safeDistance: если расстояние от HumanoidRootPart до земли больше этого значения (в studs),
-- мы переводим персонажа в PlatformStand, чтобы сервер не считал падение нормальным.
local safeDistance = 7  
-- Интервал проверки (в секундах)
local checkInterval = 0.05

-- Функция, выполняющая проверку расстояния до земли и переключающая PlatformStand
local function antiFallDamagePlatformStand()
    if state.isNoFallDamage and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local character = player.Character
        local hrp = character.HumanoidRootPart
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                local origin = hrp.Position
                local direction = Vector3.new(0, -1, 0)
                local params = RaycastParams.new()
                params.FilterDescendantsInstances = {character}
                params.FilterType = Enum.RaycastFilterType.Blacklist
                local result = workspace:Raycast(origin, direction * 100, params)
                if result then
                    local distance = (origin - result.Position).Magnitude
                    if distance > safeDistance then
                        humanoid.PlatformStand = true
                    else
                        humanoid.PlatformStand = false
                    end
                else
                    humanoid.PlatformStand = true
                end
            else
                humanoid.PlatformStand = false
            end
        end
    end
end

-- Запускаем периодическую проверку
spawn(function()
    while wait(checkInterval) do
        antiFallDamagePlatformStand()
    end
end)

-- Переключатель режима отключения урона от падения
local function toggleNoFallDamage()
    state.isNoFallDamage = not state.isNoFallDamage
    if state.isNoFallDamage then
        UI.noFallDamageButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
        UI.noFallDamageButton.TextColor3 = Color3.fromRGB(0,0,0)
        -- Передаём сетевое управление персонажу
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart:SetNetworkOwner(player)
        end
    else
        UI.noFallDamageButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
        UI.noFallDamageButton.TextColor3 = Color3.fromRGB(255,255,255)
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.PlatformStand = false
        end
    end
end

UI.noFallDamageButton.MouseButton1Click:Connect(toggleNoFallDamage)

------------------------------------------------------------
-- МОДУЛЬ: Обработка ввода для скорости и прыжка
------------------------------------------------------------
UI.speedButton.MouseButton1Click:Connect(function()
	UI.speedButton.Visible = false
	UI.speedInput.Visible = true
	UI.speedInput:CaptureFocus()
	UI.speedInput.Text = ""
end)
UI.speedInput.FocusLost:Connect(function(enterPressed)
	if not enterPressed then
		UI.speedInput.Visible = false
		UI.speedButton.Visible = true
		UI.speedInput.Text = tostring(state.currentSpeed)
		return
	end
	local inputSpeed = tonumber(UI.speedInput.Text)
	if inputSpeed then
		inputSpeed = math.clamp(inputSpeed, state.minSpeed, state.maxSpeed)
		updateWalkSpeed(inputSpeed)
		local percentage = (inputSpeed - state.minSpeed) / (state.maxSpeed - state.minSpeed)
		updateSliderButtonPosition(UI.speedSlider, UI.sliderButton, percentage)
	else
		inputSpeed = state.currentSpeed
	end
	UI.speedButton.Text = "Скорость: " .. inputSpeed
	UI.speedInput.Visible = false
	UI.speedButton.Visible = true
end)

UI.jumpButton.MouseButton1Click:Connect(function()
	UI.jumpButton.Visible = false
	UI.jumpInput.Visible = true
	UI.jumpInput:CaptureFocus()
	UI.jumpInput.Text = ""
end)
UI.jumpInput.FocusLost:Connect(function(enterPressed)
	if not enterPressed then
		UI.jumpInput.Visible = false
		UI.jumpButton.Visible = true
		UI.jumpInput.Text = tostring(state.currentJump)
		return
	end
	local inputJump = tonumber(UI.jumpInput.Text)
	if inputJump then
		inputJump = math.clamp(inputJump, state.minJump, state.maxJump)
		updateJumpPower(inputJump)
		local percentage = (inputJump - state.minJump) / (state.maxJump - state.minJump)
		updateSliderButtonPosition(UI.jumpSlider, UI.jumpSliderButton, percentage)
	else
		inputJump = state.currentJump
	end
	UI.jumpButton.Text = "Прыжок: " .. inputJump
	UI.jumpInput.Visible = false
	UI.jumpButton.Visible = true
end)

------------------------------------------------------------
-- МОДУЛЬ: Полёт
------------------------------------------------------------
local flyConnection = nil
local function updateFly(character)
	if flyConnection then
		flyConnection:Disconnect()
		flyConnection = nil
	end
	if state.isFlying and character and character:FindFirstChild("Humanoid") then
		flyConnection = UserInputService.JumpRequest:Connect(function()
			if state.isFlying and character:FindFirstChild("Humanoid") then
				character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
			end
		end)
	end
end

local function toggleFly()
	state.isFlying = not state.isFlying
	if player.Character then
		if state.isFlying then
			UI.flyButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
			UI.flyButton.TextColor3 = Color3.fromRGB(0,0,0)
			updateFly(player.Character)
		else
			UI.flyButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
			UI.flyButton.TextColor3 = Color3.fromRGB(255,255,255)
			if flyConnection then
				flyConnection:Disconnect()
				flyConnection = nil
			end
		end
	end
end
UI.flyButton.MouseButton1Click:Connect(toggleFly)

------------------------------------------------------------
-- МОДУЛЬ: NoClip
------------------------------------------------------------
local function toggleNoClip()
	state.isNoClip = not state.isNoClip
	if state.isNoClip then
		UI.noClipButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
		UI.noClipButton.TextColor3 = Color3.fromRGB(0,0,0)
	else
		UI.noClipButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
		UI.noClipButton.TextColor3 = Color3.fromRGB(255,255,255)
	end
end
UI.noClipButton.MouseButton1Click:Connect(toggleNoClip)

------------------------------------------------------------
-- МОДУЛЬ: Инициализация персонажа
------------------------------------------------------------
player.CharacterAdded:Connect(function(character)
	local humanoid = character:WaitForChild("Humanoid")
	updateWalkSpeed(state.currentSpeed)
	updateJumpPower(state.currentJump)
	if state.isFlying then
		UI.flyButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
		UI.flyButton.TextColor3 = Color3.fromRGB(0,0,0)
		updateFly(character)
	end
	-- Если режим отключения урона от падения включён – добавляем обработчик для нового персонажа
	if state.isNoFallDamage then
		-- Функция addNoFallDamage может быть добавлена по аналогии с предыдущей логикой,
		-- либо проверка выполняется через периодическую функцию antiFallDamagePlatformStand
	end
end)

------------------------------------------------------------
-- МОДУЛЬ: ESP (для игроков и NPC)
------------------------------------------------------------
local activeESPs = {} -- таблица активных ESP

local function getAttachPartForPlayer(model)
	return model:FindFirstChild("Head") or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
end

local function getAttachPartForNPC(model)
	return model:FindFirstChildWhichIsA("BasePart")
end

local function addPlayerESP(character, displayName)
	if not character or not character:IsDescendantOf(workspace) then return end
	if character:FindFirstChild("ESPHighlight") then
		character.ESPHighlight:Destroy()
	end

	local espColor = Color3.new(0, 1, 0)
	local highlight = Instance.new("Highlight")
	highlight.Name = "ESPHighlight"
	highlight.FillColor = espColor
	highlight.OutlineColor = espColor
	highlight.FillTransparency = 0.5
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Parent = character

	local attachPart = getAttachPartForPlayer(character)
	if attachPart then
		if attachPart:FindFirstChild("ESPLabel") then
			attachPart.ESPLabel:Destroy()
		end
		local billboard = Instance.new("BillboardGui")
		billboard.Name = "ESPLabel"
		billboard.AlwaysOnTop = true
		billboard.Size = UDim2.new(0, 100, 0, 20)
		billboard.StudsOffset = Vector3.new(0, 3, 0)
		billboard.Parent = attachPart

		local nameLabel = Instance.new("TextLabel")
		nameLabel.Name = "NameLabel"
		nameLabel.Size = UDim2.new(1, 0, 1, 0)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = string.format("%s (0)", displayName)
		nameLabel.TextColor3 = espColor
		nameLabel.Font = Enum.Font.GothamBold
		nameLabel.TextStrokeTransparency = 0.5
		nameLabel.TextSize = 14
		nameLabel.Parent = billboard

		activeESPs[character] = {
			nameLabel = nameLabel,
			attachPart = attachPart,
			displayName = displayName,
			isNPC = false,
		}
	end

	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	end
end

local function removePlayerESP(character)
	if not character or not character:IsA("Model") then return end
	if character:FindFirstChild("ESPHighlight") then
		character.ESPHighlight:Destroy()
	end
	local attachPart = getAttachPartForPlayer(character)
	if attachPart then
		local billboard = attachPart:FindFirstChild("ESPLabel")
		if billboard then
			billboard:Destroy()
		end
	end
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
	end
	activeESPs[character] = nil
end

local function addNPCESP(npc)
	if not npc or not npc:IsDescendantOf(workspace) or not npc:IsA("Model") then return end
	local humanoid = npc:FindFirstChildWhichIsA("Humanoid")
	if not humanoid or Players:GetPlayerFromCharacter(npc) then return end

	if npc:FindFirstChild("ESPHighlight") then
		npc.ESPHighlight:Destroy()
	end

	local espColor = Color3.new(1, 0, 0)
	local highlight = Instance.new("Highlight")
	highlight.Name = "ESPHighlight"
	highlight.FillColor = espColor
	highlight.OutlineColor = espColor
	highlight.FillTransparency = 0.5
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Parent = npc

	local attachPart = getAttachPartForNPC(npc)
	if attachPart then
		if attachPart:FindFirstChild("ESPLabel") then
			attachPart.ESPLabel:Destroy()
		end
		local billboard = Instance.new("BillboardGui")
		billboard.Name = "ESPLabel"
		billboard.AlwaysOnTop = true
		billboard.Size = UDim2.new(0, 100, 0, 20)
		billboard.StudsOffset = Vector3.new(0, 3, 0)
		billboard.Parent = attachPart

		local nameLabel = Instance.new("TextLabel")
		nameLabel.Name = "NameLabel"
		nameLabel.Size = UDim2.new(1, 0, 1, 0)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = string.format("%s (0)", npc.Name)
		nameLabel.TextColor3 = espColor
		nameLabel.Font = Enum.Font.GothamBold
		nameLabel.TextStrokeTransparency = 0.5
		nameLabel.TextSize = 14
		nameLabel.Parent = billboard

		activeESPs[npc] = {
			nameLabel = nameLabel,
			attachPart = attachPart,
			displayName = npc.Name,
			isNPC = true,
		}
	end

	humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
end

local function removeNPCESP(npc)
	if not npc or not npc:IsA("Model") then return end
	if npc:FindFirstChild("ESPHighlight") then
		npc.ESPHighlight:Destroy()
	end
	local attachPart = getAttachPartForNPC(npc)
	if attachPart then
		local billboard = attachPart:FindFirstChild("ESPLabel")
		if billboard then
			billboard:Destroy()
		end
	end
	local humanoid = npc:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
	end
	activeESPs[npc] = nil
end

RunService.RenderStepped:Connect(function()
	if not (player.Character and player.Character:FindFirstChild("Head")) then return end
	local localHeadPos = player.Character.Head.Position
	for model, data in pairs(activeESPs) do
		if model and model.Parent and data.attachPart then
			local distance = (data.attachPart.Position - localHeadPos).Magnitude
			data.nameLabel.Text = string.format("%s (%d)", data.displayName, math.floor(distance))
		end
	end
end)

UI.espPlayersButton.MouseButton1Click:Connect(function()
	local espEnabled = UI.espPlayersButton.BackgroundColor3 == Color3.fromRGB(65,65,65)
	if espEnabled then
		UI.espPlayersButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
		UI.espPlayersButton.TextColor3 = Color3.fromRGB(0,0,0)
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= player and p.Character then
				addPlayerESP(p.Character, p.DisplayName)
			end
		end
	else
		UI.espPlayersButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
		UI.espPlayersButton.TextColor3 = Color3.fromRGB(255,255,255)
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= player and p.Character then
				removePlayerESP(p.Character)
			end
		end
	end
end)

UI.espNPCButton.MouseButton1Click:Connect(function()
	local espEnabled = UI.espNPCButton.BackgroundColor3 == Color3.fromRGB(65,65,65)
	if espEnabled then
		UI.espNPCButton.BackgroundColor3 = Color3.fromRGB(0,255,0)
		UI.espNPCButton.TextColor3 = Color3.fromRGB(0,0,0)
		for _, model in ipairs(workspace:GetDescendants()) do
			if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") and not Players:GetPlayerFromCharacter(model) then
				addNPCESP(model)
			end
		end
	else
		UI.espNPCButton.BackgroundColor3 = Color3.fromRGB(65,65,65)
		UI.espNPCButton.TextColor3 = Color3.fromRGB(255,255,255)
		for _, model in ipairs(workspace:GetDescendants()) do
			if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") and not Players:GetPlayerFromCharacter(model) then
				removeNPCESP(model)
			end
		end
	end
end)

Players.PlayerAdded:Connect(function(p)
	if p ~= player then
		p.CharacterAdded:Connect(function(character)
			if UI.espPlayersButton.BackgroundColor3 == Color3.fromRGB(0,255,0) then
				wait(0.1)
				addPlayerESP(character, p.DisplayName)
			end
		end)
	end
end)
for _, p in ipairs(Players:GetPlayers()) do
	if p ~= player then
		p.CharacterAdded:Connect(function(character)
			if UI.espPlayersButton.BackgroundColor3 == Color3.fromRGB(0,255,0) then
				wait(0.1)
				addPlayerESP(character, p.DisplayName)
			end
		end)
	end
end

workspace.DescendantAdded:Connect(function(child)
	if child:IsA("Model") and child:FindFirstChildWhichIsA("Humanoid") and not Players:GetPlayerFromCharacter(child) then
		if UI.espNPCButton.BackgroundColor3 == Color3.fromRGB(0,255,0) then
			wait(0.1)
			addNPCESP(child)
		end
	end
end)

------------------------------------------------------------
-- МОДУЛЬ: Обработка NoClip (каждый кадр)
------------------------------------------------------------
RunService.Stepped:Connect(function()
	if state.isNoClip and player.Character then
		for _, part in pairs(player.Character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end
end)

------------------------------------------------------------
-- МОДУЛЬ: Сброс скорости и прыжка (проверка каждый кадр)
------------------------------------------------------------
RunService.RenderStepped:Connect(function()
	if player.Character then
		local humanoid = player.Character:FindFirstChild("Humanoid")
		if humanoid then
			if humanoid.WalkSpeed ~= state.currentSpeed then
				humanoid.WalkSpeed = state.currentSpeed
			end
			if humanoid.JumpPower ~= state.currentJump then
				humanoid.JumpPower = state.currentJump
			end
		end
	end
end)

------------------------------------------------------------
-- МОДУЛЬ: Восстановление зажатого состояния кнопок при скролле
------------------------------------------------------------
local function disableAndReenableButtons(frame)
	for _, button in ipairs(frame:GetDescendants()) do
		if button:IsA("TextButton") then
			button.Active = false
			delay(0, function()
				button.Active = true
			end)
		end
	end
end

UI.contentFrame:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
	disableAndReenableButtons(UI.contentFrame)
end)
UI.teleportScrollFrame:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
	disableAndReenableButtons(UI.teleportScrollFrame)
end)
